# Copyright ©2025 | Delean Mafra, todos os direitos reservados.

"""
Esoteric languages are pretty hard to program, but it's fairly interesting to write interpreters for them!

Your task is to write a method which will interpret Befunge-93 code! Befunge-93 is a language in which the code is presented not as a series of instructions, but as instructions scattered on a 2D plane; your pointer starts at the top-left corner and defaults to moving right through the code. Note that the instruction pointer wraps around the screen! There is a singular stack which we will assume is unbounded and only contain integers. While Befunge-93 code is supposed to be restricted to 80x25, you need not be concerned with code size. Befunge-93 supports the following instructions (from Wikipedia):

0-9 Push this number onto the stack.
+ Addition: Pop a and b, then push a+b.
- Subtraction: Pop a and b, then push b-a.
* Multiplication: Pop a and b, then push a*b.
/ Integer division: Pop a and b, then push b/a, rounded down. If a is zero, push zero.
% Modulo: Pop a and b, then push the b%a. If a is zero, push zero.
! Logical NOT: Pop a value. If the value is zero, push 1; otherwise, push zero.
` (backtick) Greater than: Pop a and b, then push 1 if b>a, otherwise push zero.
> Start moving right.
< Start moving left.
^ Start moving up.
v Start moving down.
? Start moving in a random cardinal direction.
_ Pop a value; move right if value = 0, left otherwise.
| Pop a value; move down if value = 0, up otherwise.
" Start string mode: push each character's ASCII value all the way up to the next ".
: Duplicate value on top of the stack. If there is nothing on top of the stack, push a 0.
\ Swap two values on top of the stack. If there is only one value, pretend there is an extra 0 on bottom of the stack.
$ Pop value from the stack and discard it.
. Pop value and output as an integer.
, Pop value and output the ASCII character represented by the integer code that is stored in the value.
# Trampoline: Skip next cell.
p A "put" call (a way to store a value for later use). Pop y, x and v, then change the character at the position (x,y) in the program to the character with ASCII value v.
g A "get" call (a way to retrieve data in storage). Pop y and x, then push ASCII value of the character at that position in the program.
@ End program.
  (i.e. a space) No-op. Does nothing.
The above list is slightly modified: you'll notice if you look at the Wikipedia page that we do not use the user input instructions and dividing by zero simply yields zero.

Here's an example:

>987v>.v
v456<  :
>321 ^ _@
will create the output 123456789.

So what you must do is create a function such that when you pass in the Befunge code, the function returns the output that would be generated by the code. So, for example:

"123456789".equals(new BefungeInterpreter().interpret(">987v>.v\nv456<  :\n>321 ^ _@")
This test case will be added for you.

Sample Tests
test.assert_equals(interpret('>987v>.v\nv456<  :\n>321 ^ _@'), '123456789')


Solução inicial:

def interpret(code):
    output = ""
    # TODO: Interpret the code!
    return output
    
"""



import random

class BefungeInterpreter:
    def __init__(self):
        self.stack = []
        self.direction = '>'
        self.output = ''
        self.string_mode = False
        self.x = 0
        self.y = 0

    def interpret(self, code):
        grid = [list(line) for line in code.split('\n')]
        max_y = len(grid)
        max_x = max(len(row) for row in grid)

        while True:
            cell = grid[self.y][self.x]

            if self.string_mode and cell != '"':
                self.stack.append(ord(cell))
            else:
                if cell.isdigit():
                    self.stack.append(int(cell))
                elif cell == '+':
                    a = self.stack.pop()
                    b = self.stack.pop()
                    self.stack.append(a + b)
                elif cell == '-':
                    a = self.stack.pop()
                    b = self.stack.pop()
                    self.stack.append(b - a)
                elif cell == '*':
                    a = self.stack.pop()
                    b = self.stack.pop()
                    self.stack.append(a * b)
                elif cell == '/':
                    a = self.stack.pop()
                    b = self.stack.pop()
                    self.stack.append(0 if a == 0 else b // a)
                elif cell == '%':
                    a = self.stack.pop()
                    b = self.stack.pop()
                    self.stack.append(0 if a == 0 else b % a)
                elif cell == '!':
                    a = self.stack.pop()
                    self.stack.append(1 if a == 0 else 0)
                elif cell == '`':
                    a = self.stack.pop()
                    b = self.stack.pop()
                    self.stack.append(1 if b > a else 0)
                elif cell == '>':
                    self.direction = '>'
                elif cell == '<':
                    self.direction = '<'
                elif cell == '^':
                    self.direction = '^'
                elif cell == 'v':
                    self.direction = 'v'
                elif cell == '?':
                    self.direction = random.choice(['>', '<', '^', 'v'])
                elif cell == '_':
                    a = self.stack.pop()
                    self.direction = '>' if a == 0 else '<'
                elif cell == '|':
                    a = self.stack.pop()
                    self.direction = 'v' if a == 0 else '^'
                elif cell == '"':
                    self.string_mode = not self.string_mode
                elif cell == ':':
                    a = self.stack[-1] if self.stack else 0
                    self.stack.append(a)
                elif cell == '\\':
                    a = self.stack.pop() if self.stack else 0
                    b = self.stack.pop() if self.stack else 0
                    self.stack.append(a)
                    self.stack.append(b)
                elif cell == '$':
                    self.stack.pop()
                elif cell == '.':
                    self.output += str(self.stack.pop())
                elif cell == ',':
                    self.output += chr(self.stack.pop())
                elif cell == '#':
                    self.move(grid, max_x, max_y)
                elif cell == 'p':
                    y = self.stack.pop()
                    x = self.stack.pop()
                    v = self.stack.pop()
                    grid[y][x] = chr(v)
                elif cell == 'g':
                    y = self.stack.pop()
                    x = self.stack.pop()
                    self.stack.append(ord(grid[y][x]))
                elif cell == '@':
                    return self.output
                # No-op for spaces

            self.move(grid, max_x, max_y)

    def move(self, grid, max_x, max_y):
        if self.direction == '>':
            self.x = (self.x + 1) % max_x
        elif self.direction == '<':
            self.x = (self.x - 1) % max_x
        elif self.direction == '^':
            self.y = (self.y - 1) % max_y
        elif self.direction == 'v':
            self.y = (self.y + 1) % max_y

def interpret(code):
    interpreter = BefungeInterpreter()
    return interpreter.interpret(code)
